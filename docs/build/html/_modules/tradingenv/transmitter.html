<!DOCTYPE html>

<html lang="env" data-content_root="../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>tradingenv.transmitter &#8212; tradingenv 0.1.1 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=b76e3c8a" />
    <link rel="stylesheet" type="text/css" href="../../_static/alabaster.css?v=039e1c02" />
    <script src="../../_static/documentation_options.js?v=de76930b"></script>
    <script src="../../_static/doctools.js?v=888ff710"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for tradingenv.transmitter</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;TradingEnv must receive events in order to update its state during a</span>
<span class="sd">simulation. This could either be done by the client with TradingEnv.add_event</span>
<span class="sd">(low-level) OR by providing a AbstractTransmitter when instancing TradingEnv (</span>
<span class="sd">high-level, recommended).&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">tradingenv.events</span> <span class="kn">import</span> <span class="n">IEvent</span><span class="p">,</span> <span class="n">EventNBBO</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Iterable</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Type</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">,</span> <span class="n">Tuple</span>
<span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">datetime</span><span class="p">,</span> <span class="n">timezone</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span><span class="p">,</span> <span class="n">OrderedDict</span>
<span class="kn">from</span> <span class="nn">abc</span> <span class="kn">import</span> <span class="n">ABC</span><span class="p">,</span> <span class="n">abstractmethod</span>
<span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">timedelta</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">bisect</span>
<span class="kn">import</span> <span class="nn">inspect</span>
<span class="kn">import</span> <span class="nn">random</span>

<span class="n">TRAINING_SET</span> <span class="o">=</span> <span class="s2">&quot;training-set&quot;</span>
<span class="n">TEST_SET</span> <span class="o">=</span> <span class="s2">&quot;test-set&quot;</span>


<div class="viewcode-block" id="AbstractTransmitter">
<a class="viewcode-back" href="../../tradingenv.html#tradingenv.transmitter.AbstractTransmitter">[docs]</a>
<span class="k">class</span> <span class="nc">AbstractTransmitter</span><span class="p">(</span><span class="n">ABC</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Implementations of this interface take care of delivering events to</span>
<span class="sd">    the trading environment during the interaction of the agent with the</span>
<span class="sd">    environment at pre-specified timesteps.&quot;&quot;&quot;</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">_reset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fold_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">TRAINING_SET</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Iterator protocol.&quot;&quot;&quot;</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">_next</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">IEvent</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="n">IEvent</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Iterator protocol.&quot;&quot;&quot;</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">_create_partitions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">latency</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">0.</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create partitions of Events, sorted chronologically.&quot;&quot;&quot;</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">_now</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">datetime</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns current time.&quot;&quot;&quot;</span>

<div class="viewcode-block" id="AbstractTransmitter.add_events">
<a class="viewcode-back" href="../../tradingenv.html#tradingenv.transmitter.AbstractTransmitter.add_events">[docs]</a>
    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">add_events</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">events</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">IEvent</span><span class="p">]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;&quot;&quot;&quot;</span></div>
</div>



<div class="viewcode-block" id="AsynchronousTransmitter">
<a class="viewcode-back" href="../../tradingenv.html#tradingenv.transmitter.AsynchronousTransmitter">[docs]</a>
<span class="k">class</span> <span class="nc">AsynchronousTransmitter</span><span class="p">(</span><span class="n">AbstractTransmitter</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;This AbstractTransmitter does not schedule any event to the TradingEnv.</span>
<span class="sd">    Suitable for when deploying to production your code.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This iterator never ends (it keeps returning empty lists), so len</span>
<span class="sd">        returns np.inf.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">(events: 0, timesteps: inf)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_reset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Iterator protocol.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">_next</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">IEvent</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="n">IEvent</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Iterator protocol. Returns an empty list.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(),</span> <span class="nb">list</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_create_partitions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">latency</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">0.</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;No need to create partitions.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">_now</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">datetime</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns current UTC time as a datetime object with timezone.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">datetime</span><span class="o">.</span><span class="n">utcnow</span><span class="p">()</span><span class="c1">#.replace(tzinfo=timezone.utc)</span>

<div class="viewcode-block" id="AsynchronousTransmitter.add_events">
<a class="viewcode-back" href="../../tradingenv.html#tradingenv.transmitter.AsynchronousTransmitter.add_events">[docs]</a>
    <span class="k">def</span> <span class="nf">add_events</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">events</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">IEvent</span><span class="p">]):</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">()</span></div>
</div>



<div class="viewcode-block" id="PartitionTimeRanges">
<a class="viewcode-back" href="../../tradingenv.html#tradingenv.transmitter.PartitionTimeRanges">[docs]</a>
<span class="k">class</span> <span class="nc">PartitionTimeRanges</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">folds</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">folds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">folds</span> <span class="o">=</span> <span class="p">{</span><span class="n">TRAINING_SET</span><span class="p">:</span> <span class="p">[</span><span class="n">datetime</span><span class="o">.</span><span class="n">min</span><span class="p">,</span> <span class="n">datetime</span><span class="o">.</span><span class="n">max</span><span class="p">]}</span>

        <span class="c1"># Parse split to ordered dictionary sorted by start date.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">folds</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">folds</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">verify_start_before_end</span><span class="p">()</span>
        <span class="c1"># I&#39;m allowing partitions to overlap as some use cases such as</span>
        <span class="c1"># walk-forward partitions need support for this.</span>
        <span class="c1"># self.verify_overlaps()</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">folds</span><span class="p">[</span><span class="n">item</span><span class="p">]</span>

<div class="viewcode-block" id="PartitionTimeRanges.verify_start_before_end">
<a class="viewcode-back" href="../../tradingenv.html#tradingenv.transmitter.PartitionTimeRanges.verify_start_before_end">[docs]</a>
    <span class="k">def</span> <span class="nf">verify_start_before_end</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Verify that start &lt; end across all datasets.&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">folds</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">end</span> <span class="o">&lt;</span> <span class="n">start</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Dataset &#39;</span><span class="si">{}</span><span class="s2">&#39; end date </span><span class="si">{}</span><span class="s2"> must be more recent than the &quot;</span>
                    <span class="s2">&quot;start date </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>
                <span class="p">)</span></div>


<div class="viewcode-block" id="PartitionTimeRanges.verify_overlaps">
<a class="viewcode-back" href="../../tradingenv.html#tradingenv.transmitter.PartitionTimeRanges.verify_overlaps">[docs]</a>
    <span class="k">def</span> <span class="nf">verify_overlaps</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Verify absence of any overlap across all time windows.&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">key1</span><span class="p">,</span> <span class="p">(</span><span class="n">start1</span><span class="p">,</span> <span class="n">end1</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">folds</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">key2</span><span class="p">,</span> <span class="p">(</span><span class="n">start2</span><span class="p">,</span> <span class="n">end2</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">folds</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">key1</span> <span class="o">!=</span> <span class="n">key2</span> <span class="ow">and</span> <span class="n">start1</span> <span class="o">&lt;=</span> <span class="n">start2</span> <span class="o">&lt;=</span> <span class="n">end1</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;Dataset &#39;</span><span class="si">{}</span><span class="s2">&#39; (</span><span class="si">{}</span><span class="s2">:</span><span class="si">{}</span><span class="s2">)overlaps with &#39;</span><span class="si">{}</span><span class="s2">&#39; (</span><span class="si">{}</span><span class="s2">:</span><span class="si">{}</span><span class="s2">)&quot;</span>
                        <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">key1</span><span class="p">,</span> <span class="n">start1</span><span class="p">,</span> <span class="n">end1</span><span class="p">,</span> <span class="n">key2</span><span class="p">,</span> <span class="n">start2</span><span class="p">,</span> <span class="n">end2</span><span class="p">)</span>
                    <span class="p">)</span></div>
</div>



<div class="viewcode-block" id="Folds">
<a class="viewcode-back" href="../../tradingenv.html#tradingenv.transmitter.Folds">[docs]</a>
<span class="k">class</span> <span class="nc">Folds</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">timesteps</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">datetime</span><span class="p">],</span>
        <span class="n">train_start</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">,</span>
        <span class="n">train_end</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">,</span>
        <span class="n">test_start</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">,</span>
        <span class="n">test_end</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">timesteps</span> <span class="o">=</span> <span class="n">timesteps</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">train_start</span> <span class="o">=</span> <span class="n">train_start</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">train_end</span> <span class="o">=</span> <span class="n">train_end</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">test_start</span> <span class="o">=</span> <span class="n">test_start</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">test_end</span> <span class="o">=</span> <span class="n">test_end</span>

<div class="viewcode-block" id="Folds.as_time">
<a class="viewcode-back" href="../../tradingenv.html#tradingenv.transmitter.Folds.as_time">[docs]</a>
    <span class="k">def</span> <span class="nf">as_time</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns Folds instance storing timesteps associated with the end</span>
<span class="sd">        and start of each fold.&quot;&quot;&quot;</span>
        <span class="n">timesteps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">timesteps</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Folds</span><span class="p">(</span>
            <span class="n">timesteps</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">timesteps</span><span class="p">,</span>
            <span class="n">train_start</span><span class="o">=</span><span class="n">timesteps</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">train_start</span><span class="p">],</span>
            <span class="n">train_end</span><span class="o">=</span><span class="n">timesteps</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">train_end</span><span class="p">],</span>
            <span class="n">test_start</span><span class="o">=</span><span class="n">timesteps</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">test_start</span><span class="p">],</span>
            <span class="n">test_end</span><span class="o">=</span><span class="n">timesteps</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">test_end</span><span class="p">],</span>
        <span class="p">)</span></div>
</div>



<div class="viewcode-block" id="Transmitter">
<a class="viewcode-back" href="../../tradingenv.html#tradingenv.transmitter.Transmitter">[docs]</a>
<span class="k">class</span> <span class="nc">Transmitter</span><span class="p">(</span><span class="n">AbstractTransmitter</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;AbstractTransmitter takes care of sending Event(s) to TradingEnv while</span>
<span class="sd">    interacting with the environment at specified timesteps. You want to use</span>
<span class="sd">    this class to run a backtest in order to schedule at what time the Event(s)</span>
<span class="sd">    (e.g. market prices or alternative data) should trigger.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    events : List[Event]</span>
<span class="sd">        A list accumulating events to be delivered to TradingEnv during the</span>
<span class="sd">        interaction.</span>
<span class="sd">    timesteps : List[IEvent]</span>
<span class="sd">        A list accumulating timesteps at which to deliver events to</span>
<span class="sd">        TradingEnv during the interaction.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">timesteps</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">,</span>
            <span class="n">folds</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">datetime</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">markov_reset</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
            <span class="n">warmup</span><span class="p">:</span> <span class="n">timedelta</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        timesteps : Sequence</span>
<span class="sd">            A sequence of timestamps (e.g. datetime, date, timestamp). Starting</span>
<span class="sd">            from the oldest timestamp, Transmitter next will send events in</span>
<span class="sd">            batches stopping at the next timestamp (chronological order) until</span>
<span class="sd">            when the last timestep is reached.</span>
<span class="sd">        folds : Dict[str, Sequence[datetime]]</span>
<span class="sd">            A dictionary mapping fold _names (keys) to a pair (Sequence) of</span>
<span class="sd">            timesteps defining the start and end time of the fold. If not</span>
<span class="sd">            provided, all timesteps will belong to a single fold named</span>
<span class="sd">            &#39;training-set&#39;.</span>
<span class="sd">        markov_reset : bool</span>
<span class="sd">            If False (default), all events occurring before the date of the</span>
<span class="sd">            reset will be processed to allow calculating derived data from past</span>
<span class="sd">            information. If True, past events will not be processed. Setting</span>
<span class="sd">            this to True will speed up the time required to reset the</span>
<span class="sd">            environment.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from tradingenv.contracts import Index</span>
<span class="sd">        &gt;&gt;&gt; returns = pd.DataFrame(</span>
<span class="sd">        ...     data=np.random.normal(0, 0.001, (100, 2)),</span>
<span class="sd">        ...     columns=[Index(&#39;S&amp;P 500&#39;), Index(&#39;T-Bond&#39;)],</span>
<span class="sd">        ...     index=pd.date_range(&#39;2019-01-01&#39;, periods=100, freq=&#39;B&#39;),</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; prices = (1 + returns).cumprod()</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # All prices belong to the training-set.</span>
<span class="sd">        &gt;&gt;&gt; transmitter = Transmitter(timesteps=prices.index)</span>
<span class="sd">        &gt;&gt;&gt; transmitter.add_prices(prices)</span>

<span class="sd">        &gt;&gt;&gt; # Partition prices between training and test set.</span>
<span class="sd">        &gt;&gt;&gt; transmitter = Transmitter(</span>
<span class="sd">        ...     timesteps=prices.index,</span>
<span class="sd">        ...     folds={</span>
<span class="sd">        ...         &#39;training-set&#39;: [datetime(2019, 1, 1), datetime(2019, 3, 1)],</span>
<span class="sd">        ...         &#39;test-set&#39;: [datetime(2019, 3, 2), datetime(2019, 5, 1)],</span>
<span class="sd">        ...     },</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; transmitter.add_prices(prices)</span>
<span class="sd">        &gt;&gt;&gt; transmitter._create_partitions()</span>
<span class="sd">        &gt;&gt;&gt; transmitter._reset(fold_name=&#39;test-set&#39;)</span>

<span class="sd">        &gt;&gt;&gt; # Retrieve batches of events, then processed by TradingEnv.add_event</span>
<span class="sd">        &gt;&gt;&gt; events_batch_0 = transmitter._next()</span>
<span class="sd">        &gt;&gt;&gt; events_batch_1 = transmitter._next()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: add optional argument events.</span>
        <span class="c1"># TODO: make timesteps optional.</span>
        <span class="c1"># TODO: is it an issue in case of mixed pd.Timestamp and datetime?</span>
        <span class="c1"># Inputs.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">timesteps</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">datetime</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">timesteps</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_folds</span> <span class="o">=</span> <span class="n">PartitionTimeRanges</span><span class="p">(</span><span class="n">folds</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_markov_reset</span> <span class="o">=</span> <span class="n">markov_reset</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_warmup</span> <span class="o">=</span> <span class="n">warmup</span>

        <span class="c1"># Attributes.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">IEvent</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fold_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_start_date</span><span class="p">:</span> <span class="n">datetime</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_end_date</span><span class="p">:</span> <span class="n">datetime</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_partition_nonlatent</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">datetime</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">IEvent</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Length of the iterator, corresponding to the number of timesteps.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_partition_nonlatent</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">nr_timesteps</span> <span class="o">=</span> <span class="s2">&quot;?&quot;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_partition_nonlatent</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_partition_nonlatent</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="si">{cls}</span><span class="s2">(events: </span><span class="si">{nr_events}</span><span class="s2">, timesteps: </span><span class="si">{nr_timesteps}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="bp">cls</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
            <span class="n">nr_events</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">),</span>
            <span class="n">nr_timesteps</span><span class="o">=</span><span class="n">nr_timesteps</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_reset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fold_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">TRAINING_SET</span><span class="p">,</span> <span class="n">episode_length</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">sampling_span</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        fold_name : str</span>
<span class="sd">            Fold id must have been specified in Transmitter.folds, which is</span>
<span class="sd">            &#39;training-set&#39; by default.</span>
<span class="sd">        episode_length : int</span>
<span class="sd">            Transmitter.next will stop returning events episode_length is</span>
<span class="sd">            reached. By default, there is no maximum length.</span>
<span class="sd">            If you are training reinforcement learning agents, setting this</span>
<span class="sd">            parameter might be good practice when episodes are very long</span>
<span class="sd">            (continuing tasks) or you want you use a RNN policy as training</span>
<span class="sd">            from long sequences might be harder for back-propagation through</span>
<span class="sd">            time.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_partition_nonlatent</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_create_partitions</span><span class="p">()</span>
        <span class="n">start_date</span><span class="p">,</span> <span class="n">end_date</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_folds</span><span class="p">[</span><span class="n">fold_name</span><span class="p">]</span>
        <span class="n">timesteps</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_partition_nonlatent</span><span class="p">)</span> <span class="o">|</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_partition_latent</span><span class="p">)</span>
        <span class="n">steps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">timesteps</span><span class="p">))</span>
        <span class="n">steps</span> <span class="o">=</span> <span class="n">steps</span><span class="p">[</span><span class="n">start_date</span> <span class="o">&lt;=</span> <span class="n">steps</span><span class="p">]</span>
        <span class="n">steps</span> <span class="o">=</span> <span class="n">steps</span><span class="p">[</span><span class="n">steps</span> <span class="o">&lt;=</span> <span class="n">end_date</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">episode_length</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">start_dates</span> <span class="o">=</span> <span class="n">steps</span><span class="p">[:</span> <span class="o">-</span><span class="p">(</span><span class="n">episode_length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span>
            <span class="k">if</span> <span class="n">sampling_span</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">gamma</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">sampling_span</span><span class="p">)</span>
                <span class="n">p</span> <span class="o">=</span> <span class="n">gamma</span> <span class="o">**</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">start_dates</span><span class="p">))[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">p</span> <span class="o">/=</span> <span class="n">p</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">p</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">start_date_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">start_dates</span><span class="p">)),</span> <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="p">)</span>
            <span class="n">end_date_idx</span> <span class="o">=</span> <span class="n">start_date_idx</span> <span class="o">+</span> <span class="n">episode_length</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">start_date</span> <span class="o">=</span> <span class="n">steps</span><span class="p">[</span><span class="n">start_date_idx</span><span class="p">]</span>
            <span class="n">end_date</span> <span class="o">=</span> <span class="n">steps</span><span class="p">[</span><span class="n">end_date_idx</span><span class="p">]</span>
            <span class="n">steps</span> <span class="o">=</span> <span class="n">steps</span><span class="p">[</span><span class="n">start_date_idx</span> <span class="p">:</span> <span class="n">end_date_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>

        <span class="c1"># Done. Save to attributes.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_step_nr</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_current_time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_steps</span> <span class="o">=</span> <span class="n">steps</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_start_date</span> <span class="o">=</span> <span class="n">start_date</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_end_date</span> <span class="o">=</span> <span class="n">end_date</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fold_name</span> <span class="o">=</span> <span class="n">fold_name</span>

    <span class="k">def</span> <span class="nf">_next</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">IEvent</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="n">IEvent</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Latent events front run the action to simulate a latency. Then the</span>
<span class="sd">        action if reflected in the trading environment, then non-latent events</span>
<span class="sd">        are run, then the new state is returned.&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_current_time</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_steps</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_step_nr</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">StopIteration</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_step_nr</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_step_nr</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_markov_reset</span><span class="p">):</span>
            <span class="n">origin</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_current_time</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_warmup</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_warmup</span> <span class="k">else</span> <span class="n">datetime</span><span class="o">.</span><span class="n">min</span>
            <span class="c1">#start_date, end_date = self._folds[self._fold_name]</span>
            <span class="n">events_latent</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">e</span> <span class="k">for</span> <span class="n">t</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_partition_latent</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">origin</span> <span class="o">&lt;=</span> <span class="n">t</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_current_time</span>
            <span class="p">]</span>
            <span class="n">events_latent</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="o">*</span><span class="n">events_latent</span><span class="p">))</span>
            <span class="n">events_nonlatent</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">events</span> <span class="k">for</span> <span class="n">t</span><span class="p">,</span> <span class="n">events</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_partition_nonlatent</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">origin</span> <span class="o">&lt;=</span> <span class="n">t</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_current_time</span>
            <span class="p">]</span>
            <span class="n">events_nonlatent</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="o">*</span><span class="n">events_nonlatent</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">events_latent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_partition_latent</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_current_time</span><span class="p">]</span>
            <span class="n">events_nonlatent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_partition_nonlatent</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_current_time</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">events_latent</span><span class="p">,</span> <span class="n">events_nonlatent</span>

    <span class="k">def</span> <span class="nf">_now</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">datetime</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns current UTC time as a datetime object with timezone.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_current_time</span>

<div class="viewcode-block" id="Transmitter.add_events">
<a class="viewcode-back" href="../../tradingenv.html#tradingenv.transmitter.Transmitter.add_events">[docs]</a>
    <span class="k">def</span> <span class="nf">add_events</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">events</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">IEvent</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        events : Iterable[IEvent]</span>
<span class="sd">            Events to be send to the environment. The time at which the Event</span>
<span class="sd">            will trigger corresponds to the first timestep greater or equal</span>
<span class="sd">            to Event.time.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">events</span><span class="p">)</span></div>


<div class="viewcode-block" id="Transmitter.add_timesteps">
<a class="viewcode-back" href="../../tradingenv.html#tradingenv.transmitter.Transmitter.add_timesteps">[docs]</a>
    <span class="k">def</span> <span class="nf">add_timesteps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timesteps</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">datetime</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        timesteps : Iterable[datetime]</span>
<span class="sd">            Events will be sent at the intervals specified here.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">timesteps</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">timesteps</span><span class="p">)</span></div>


<div class="viewcode-block" id="Transmitter.add_prices">
<a class="viewcode-back" href="../../tradingenv.html#tradingenv.transmitter.Transmitter.add_prices">[docs]</a>
    <span class="k">def</span> <span class="nf">add_prices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prices</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">spread</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        prices : pandas.DataFrame</span>
<span class="sd">            A pandas.DataFrame with the following characteristics:</span>
<span class="sd">            - index: datetime objects</span>
<span class="sd">            - columns: contract _names</span>
<span class="sd">            - values: mid prices.</span>
<span class="sd">            All mid prices will be mapped to EventNBBOs to be delivered while</span>
<span class="sd">            interacting with TradingEnv. No timesteps are added.</span>
<span class="sd">        spread : float</span>
<span class="sd">            Spread to be applied to mid_prices (zero by default). For example,</span>
<span class="sd">            if spread=0.001, then there will be a 0.1% bid-ask spread</span>
<span class="sd">            for all prices.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">prices</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span> <span class="o">=</span> <span class="n">prices</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">contract</span> <span class="ow">in</span> <span class="n">prices</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="n">series</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span> <span class="o">=</span> <span class="n">prices</span><span class="p">[</span><span class="n">contract</span><span class="p">]</span>
            <span class="n">series</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">time</span><span class="p">,</span> <span class="n">price</span> <span class="ow">in</span> <span class="n">series</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">half_spread</span> <span class="o">=</span> <span class="n">price</span> <span class="o">*</span> <span class="n">spread</span> <span class="o">/</span> <span class="mi">2</span>
                <span class="n">event</span> <span class="o">=</span> <span class="n">EventNBBO</span><span class="p">(</span>
                    <span class="n">time</span><span class="o">=</span><span class="n">time</span><span class="p">,</span>
                    <span class="n">contract</span><span class="o">=</span><span class="n">contract</span><span class="p">,</span>
                    <span class="n">bid_price</span><span class="o">=</span><span class="n">price</span> <span class="o">-</span> <span class="n">half_spread</span><span class="p">,</span>
                    <span class="n">ask_price</span><span class="o">=</span><span class="n">price</span> <span class="o">+</span> <span class="n">half_spread</span><span class="p">,</span>
                    <span class="n">bid_size</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span>
                    <span class="n">ask_size</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">event</span><span class="p">)</span></div>


<div class="viewcode-block" id="Transmitter.add_custom_events">
<a class="viewcode-back" href="../../tradingenv.html#tradingenv.transmitter.Transmitter.add_custom_events">[docs]</a>
    <span class="k">def</span> <span class="nf">add_custom_events</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">data</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
        <span class="n">event_class</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="n">IEvent</span><span class="p">],</span>
        <span class="n">mapping</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : pandas.DataFrame</span>
<span class="sd">            Every row of this pandas.DataFrame will be used to create</span>
<span class="sd">            instance of EventType passing columns-state pairs as kwargs. The</span>
<span class="sd">            index of the dataframe must be of type Datetime and will be used</span>
<span class="sd">            to set Event.time.</span>
<span class="sd">        event_class : Type[Event]</span>
<span class="sd">            Arguments in EventType.__init__ will be searched from the columns</span>
<span class="sd">            of the dataframe and set accordingly.</span>
<span class="sd">        mapping : Dict[str, str]</span>
<span class="sd">            A dictionary mapping df column _names to attribute _names of</span>
<span class="sd">            EventType. There is no need to provide a mapping if the columns</span>
<span class="sd">            _names are exactly the same as the attribute _names of EventType.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from tradingenv.events import IEvent</span>
<span class="sd">        &gt;&gt;&gt; from tradingenv.transmitter import Transmitter</span>
<span class="sd">        &gt;&gt;&gt; from datetime import datetime</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; class NewsSentiment(IEvent):</span>
<span class="sd">        ...     def __init__(self, headline: str, sentiment: float):</span>
<span class="sd">        ...         self.headline = headline</span>
<span class="sd">        ...         self.sentiment = sentiment</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; dataset = pd.DataFrame(</span>
<span class="sd">        ...     data=[</span>
<span class="sd">        ...         [&#39;This is a very good news!&#39;, +0.7],</span>
<span class="sd">        ...         [&#39;A kind of bad stuff has happened&#39;, -0.5],</span>
<span class="sd">        ...         [&#39;Neutral news&#39;, 0],</span>
<span class="sd">        ...     ],</span>
<span class="sd">        ...     columns=[&#39;headline&#39;, &#39;sentiment&#39;],</span>
<span class="sd">        ...     index=[</span>
<span class="sd">        ...         datetime(2019, 1, 1),</span>
<span class="sd">        ...         datetime(2019, 1, 1),</span>
<span class="sd">        ...         datetime(2019, 1, 2),</span>
<span class="sd">        ... ])</span>
<span class="sd">        &gt;&gt;&gt; transmitter = Transmitter(timesteps=dataset.index)</span>
<span class="sd">        &gt;&gt;&gt; transmitter.add_custom_events(dataset, NewsSentiment)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">mapping</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">mapping</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DatetimeIndex</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;data.index must be of type pandas.DatetimeIndex.&quot;</span><span class="p">)</span>
        <span class="n">parameters</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">inspect</span><span class="o">.</span><span class="n">signature</span><span class="p">(</span><span class="n">event_class</span><span class="o">.</span><span class="fm">__init__</span><span class="p">)</span><span class="o">.</span><span class="n">parameters</span><span class="p">)</span>
        <span class="n">parameters</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;self&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
            <span class="c1"># If EventType requires one of the following missing keys during</span>
            <span class="c1"># its initialization, we use the index as a workaround.</span>
            <span class="n">kwargs</span> <span class="o">=</span> <span class="n">row</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;Date&quot;</span><span class="p">,</span> <span class="s2">&quot;date&quot;</span><span class="p">,</span> <span class="s2">&quot;Time&quot;</span><span class="p">,</span> <span class="s2">&quot;time&quot;</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">row</span><span class="o">.</span><span class="n">index</span><span class="p">:</span>
                    <span class="n">kwargs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">index</span>

            <span class="c1"># Change attribute id according to mapping.</span>
            <span class="k">for</span> <span class="n">col_name</span><span class="p">,</span> <span class="n">attr_name</span> <span class="ow">in</span> <span class="n">mapping</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="n">attr_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">col_name</span><span class="p">)</span>

            <span class="c1"># Keep only relevant keys.</span>
            <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">parameters</span><span class="p">}</span>

            <span class="c1"># Create custom event.</span>
            <span class="n">event</span> <span class="o">=</span> <span class="n">event_class</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="n">event</span><span class="o">.</span><span class="n">time</span> <span class="o">=</span> <span class="n">index</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">event</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="nf">_min_timesteps_diff</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns minimum time gap in seconds between all timesteps.&quot;&quot;&quot;</span>
        <span class="n">gaps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">timesteps</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">min</span><span class="p">([</span><span class="n">gap</span><span class="o">.</span><span class="n">total_seconds</span><span class="p">()</span> <span class="k">for</span> <span class="n">gap</span> <span class="ow">in</span> <span class="n">gaps</span><span class="p">],</span> <span class="n">default</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_create_partitions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">latency</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create batches of events with bisect according to the timesteps.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">timesteps</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Transmitter delivers events to TradingEnv at &quot;</span>
                <span class="s2">&quot;timesteps indicated by Transmitter.timesteps, &quot;</span>
                <span class="s2">&quot;which is empty. Have you called &quot;</span>
                <span class="s2">&quot;Transmitter.add_timesteps at least once?&quot;</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">timesteps</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">timesteps</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">latency</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_min_timesteps_diff</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Parameter &#39;latency&#39;=</span><span class="si">{}</span><span class="s2">s must be smaller than the minimum &quot;</span>
                <span class="s2">&quot;time gap between each timesteps, corresponding to </span><span class="si">{}</span><span class="s2">s.&quot;</span>
                <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">latency</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_min_timesteps_diff</span><span class="p">())</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_partition_nonlatent</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_partition_latent</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="c1"># TODO: Test sorted. It guarantees that all events associated with a</span>
        <span class="c1">#  timestamp are sorted. This avoids possible surprises when processing</span>
        <span class="c1">#  events by Feature.</span>
        <span class="n">events</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">events</span> <span class="k">if</span> <span class="n">e</span><span class="o">.</span><span class="n">time</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">timesteps</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_markov_reset</span><span class="p">:</span>
            <span class="n">events</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">events</span> <span class="k">if</span> <span class="n">e</span><span class="o">.</span><span class="n">time</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">timesteps</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="k">for</span> <span class="n">event</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">events</span><span class="p">):</span>
            <span class="c1"># Events which occur after the last timestep are never run.</span>
            <span class="k">if</span> <span class="n">event</span><span class="o">.</span><span class="n">time</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">timesteps</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                <span class="c1"># IEvent is associated to first timestep that is &gt;= event.time</span>
                <span class="n">index</span> <span class="o">=</span> <span class="n">bisect</span><span class="o">.</span><span class="n">bisect_left</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">timesteps</span><span class="p">,</span> <span class="n">event</span><span class="o">.</span><span class="n">time</span><span class="p">)</span>
                <span class="n">index_previous</span> <span class="o">=</span> <span class="n">index</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="n">timestep</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">timesteps</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
                <span class="n">timestep_previous</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">timesteps</span><span class="p">[</span><span class="n">index_previous</span><span class="p">]</span> <span class="k">if</span> <span class="n">index_previous</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">datetime</span><span class="p">(</span><span class="mi">1800</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># or pd.Timestamp.min?</span>
                <span class="n">sec_since_timestep</span> <span class="o">=</span> <span class="p">(</span><span class="n">event</span><span class="o">.</span><span class="n">time</span> <span class="o">-</span> <span class="n">timestep_previous</span><span class="p">)</span><span class="o">.</span><span class="n">total_seconds</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">sec_since_timestep</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s1">&#39;Unexpected sec_since_timestep=</span><span class="si">{}</span><span class="s1">&#39;</span>
                        <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">sec_since_timestep</span><span class="p">)</span>
                    <span class="p">)</span>
                <span class="k">if</span> <span class="n">sec_since_timestep</span> <span class="o">&lt;=</span> <span class="n">latency</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_partition_latent</span><span class="p">[</span><span class="n">timestep</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">event</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_partition_nonlatent</span><span class="p">[</span><span class="n">timestep</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">event</span><span class="p">)</span>

<div class="viewcode-block" id="Transmitter.walk_forward">
<a class="viewcode-back" href="../../tradingenv.html#tradingenv.transmitter.Transmitter.walk_forward">[docs]</a>
    <span class="k">def</span> <span class="nf">walk_forward</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">train_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">test_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">sliding_window</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Folds</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        train_size : int</span>
<span class="sd">            Number of observations in the training folds.</span>
<span class="sd">        test_size : int</span>
<span class="sd">            Number of observation in the validation folds.</span>
<span class="sd">        sliding_window : bool</span>
<span class="sd">            If True (default), training folds will be computed using a sliding</span>
<span class="sd">            window with the same number of observations. If False, an</span>
<span class="sd">            expanding window will be used instead, so each training fold will</span>
<span class="sd">            start from the first timestep which a monotonically increasing</span>
<span class="sd">            number of observations.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        By design, the step size of the window is set to be &#39;test_size&#39;.</span>
<span class="sd">        Reasons are:</span>
<span class="sd">        - if &#39;step&#39;&lt;&#39;test_size&#39;: your validation set is not using all available</span>
<span class="sd">        information.</span>
<span class="sd">        - if &#39;step&#39;&gt;&#39;test_size&#39;: there is the risk of look-ahead bias because</span>
<span class="sd">        the next training fold will be validated on a portion of previously</span>
<span class="sd">        seen validation data.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        A Folds object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">count</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">timesteps</span><span class="p">))</span>
        <span class="n">train_start</span> <span class="o">=</span> <span class="n">count</span><span class="p">[:</span> <span class="o">-</span><span class="n">train_size</span> <span class="o">-</span> <span class="n">test_size</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">:</span> <span class="n">test_size</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">Folds</span><span class="p">(</span>
            <span class="n">timesteps</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">timesteps</span><span class="p">,</span>
            <span class="n">train_start</span><span class="o">=</span><span class="n">train_start</span> <span class="o">*</span> <span class="nb">int</span><span class="p">(</span><span class="n">sliding_window</span><span class="p">),</span>
            <span class="n">train_end</span><span class="o">=</span><span class="n">train_start</span> <span class="o">+</span> <span class="n">train_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
            <span class="n">test_start</span><span class="o">=</span><span class="n">train_start</span> <span class="o">+</span> <span class="n">train_size</span><span class="p">,</span>
            <span class="n">test_end</span><span class="o">=</span><span class="n">train_start</span> <span class="o">+</span> <span class="n">train_size</span> <span class="o">+</span> <span class="n">test_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
        <span class="p">)</span></div>
</div>

</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, Federico Fontana.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.2.6</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
    </div>

    

    
  </body>
</html>